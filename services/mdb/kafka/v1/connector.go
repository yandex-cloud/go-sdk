// Code generated by sdkgen-v2. DO NOT EDIT.
package kafkasdk

import (
	"context"

	kafka "github.com/yandex-cloud/go-genproto/yandex/cloud/mdb/kafka/v1"
	operation "github.com/yandex-cloud/go-genproto/yandex/cloud/operation"
	sdkop "github.com/yandex-cloud/go-sdk/v2/pkg/operation"
	"github.com/yandex-cloud/go-sdk/v2/pkg/transport"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/reflect/protoreflect"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// ConnectorClient provides methods for managing Connector resources of Yandex.Cloud Kafka.
type ConnectorClient interface {
	Get(context.Context, *kafka.GetConnectorRequest, ...grpc.CallOption) (*kafka.Connector, error)
	List(context.Context, *kafka.ListConnectorsRequest, ...grpc.CallOption) (*kafka.ListConnectorsResponse, error)
	Create(context.Context, *kafka.CreateConnectorRequest, ...grpc.CallOption) (*ConnectorCreateOperation, error)
	Update(context.Context, *kafka.UpdateConnectorRequest, ...grpc.CallOption) (*ConnectorUpdateOperation, error)
	Delete(context.Context, *kafka.DeleteConnectorRequest, ...grpc.CallOption) (*ConnectorDeleteOperation, error)
	Resume(context.Context, *kafka.ResumeConnectorRequest, ...grpc.CallOption) (*ConnectorResumeOperation, error)
	Pause(context.Context, *kafka.PauseConnectorRequest, ...grpc.CallOption) (*ConnectorPauseOperation, error)
}

var _ ConnectorClient = connectorClient{}

type connectorClient struct {
	connector transport.Connector
}

// NewConnectorClient returns ConnectorClient implementation.
func NewConnectorClient(connector transport.Connector) ConnectorClient {
	return connectorClient{connector}
}

// Get is an operation of Yandex.Cloud Kafka Connector service.
func (c connectorClient) Get(ctx context.Context, in *kafka.GetConnectorRequest, opts ...grpc.CallOption) (*kafka.Connector, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorGet, opts...)
	if err != nil {
		return nil, err
	}
	return kafka.NewConnectorServiceClient(connection).Get(ctx, in, opts...)
}

// List is an operation of Yandex.Cloud Kafka Connector service.
func (c connectorClient) List(ctx context.Context, in *kafka.ListConnectorsRequest, opts ...grpc.CallOption) (*kafka.ListConnectorsResponse, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorList, opts...)
	if err != nil {
		return nil, err
	}
	return kafka.NewConnectorServiceClient(connection).List(ctx, in, opts...)
}

// ConnectorCreateOperation is used to monitor the state of Create operations.
type ConnectorCreateOperation struct {
	sdkop.Operation
}

// Metadata retrieves the operation metadata.
func (o *ConnectorCreateOperation) Metadata() *kafka.CreateConnectorMetadata {
	return o.Operation.Metadata().(*kafka.CreateConnectorMetadata)
}

// Response retrieves the operation response.
func (o *ConnectorCreateOperation) Response() *kafka.Connector {
	return o.Operation.Response().(*kafka.Connector)
}

// Wait polls the operation until it's done.
func (o *ConnectorCreateOperation) Wait(ctx context.Context, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.Wait(ctx, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// WaitInterval polls the operation until it's done with custom interval.
func (o *ConnectorCreateOperation) WaitInterval(ctx context.Context, pollInterval sdkop.PollIntervalFunc, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.WaitInterval(ctx, pollInterval, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// Create is an operation of Yandex.Cloud Kafka Connector service.
// It returns an object which should be used to monitor the operation state.
func (c connectorClient) Create(ctx context.Context, in *kafka.CreateConnectorRequest, opts ...grpc.CallOption) (*ConnectorCreateOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorCreate, opts...)
	if err != nil {
		return nil, err
	}
	pb, err := kafka.NewConnectorServiceClient(connection).Create(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	op, err := sdkop.NewOperation(pb, &sdkop.Concretization{
		Poll:         c.pollOperation,
		MetadataType: (*kafka.CreateConnectorMetadata)(nil),
		ResponseType: (*kafka.Connector)(nil),
	})
	if err != nil {
		return nil, err
	}
	return &ConnectorCreateOperation{*op}, nil
}

// ConnectorUpdateOperation is used to monitor the state of Update operations.
type ConnectorUpdateOperation struct {
	sdkop.Operation
}

// Metadata retrieves the operation metadata.
func (o *ConnectorUpdateOperation) Metadata() *kafka.UpdateConnectorMetadata {
	return o.Operation.Metadata().(*kafka.UpdateConnectorMetadata)
}

// Response retrieves the operation response.
func (o *ConnectorUpdateOperation) Response() *kafka.Connector {
	return o.Operation.Response().(*kafka.Connector)
}

// Wait polls the operation until it's done.
func (o *ConnectorUpdateOperation) Wait(ctx context.Context, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.Wait(ctx, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// WaitInterval polls the operation until it's done with custom interval.
func (o *ConnectorUpdateOperation) WaitInterval(ctx context.Context, pollInterval sdkop.PollIntervalFunc, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.WaitInterval(ctx, pollInterval, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// Update is an operation of Yandex.Cloud Kafka Connector service.
// It returns an object which should be used to monitor the operation state.
func (c connectorClient) Update(ctx context.Context, in *kafka.UpdateConnectorRequest, opts ...grpc.CallOption) (*ConnectorUpdateOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorUpdate, opts...)
	if err != nil {
		return nil, err
	}
	pb, err := kafka.NewConnectorServiceClient(connection).Update(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	op, err := sdkop.NewOperation(pb, &sdkop.Concretization{
		Poll:         c.pollOperation,
		MetadataType: (*kafka.UpdateConnectorMetadata)(nil),
		ResponseType: (*kafka.Connector)(nil),
	})
	if err != nil {
		return nil, err
	}
	return &ConnectorUpdateOperation{*op}, nil
}

// ConnectorDeleteOperation is used to monitor the state of Delete operations.
type ConnectorDeleteOperation struct {
	sdkop.Operation
}

// Metadata retrieves the operation metadata.
func (o *ConnectorDeleteOperation) Metadata() *kafka.DeleteConnectorMetadata {
	return o.Operation.Metadata().(*kafka.DeleteConnectorMetadata)
}

// Response retrieves the operation response.
func (o *ConnectorDeleteOperation) Response() *emptypb.Empty {
	return o.Operation.Response().(*emptypb.Empty)
}

// Wait polls the operation until it's done.
func (o *ConnectorDeleteOperation) Wait(ctx context.Context, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	abstract, err := o.Operation.Wait(ctx, opts...)
	response, _ := abstract.(*emptypb.Empty)
	return response, err
}

// WaitInterval polls the operation until it's done with custom interval.
func (o *ConnectorDeleteOperation) WaitInterval(ctx context.Context, pollInterval sdkop.PollIntervalFunc, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	abstract, err := o.Operation.WaitInterval(ctx, pollInterval, opts...)
	response, _ := abstract.(*emptypb.Empty)
	return response, err
}

// Delete is an operation of Yandex.Cloud Kafka Connector service.
// It returns an object which should be used to monitor the operation state.
func (c connectorClient) Delete(ctx context.Context, in *kafka.DeleteConnectorRequest, opts ...grpc.CallOption) (*ConnectorDeleteOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorDelete, opts...)
	if err != nil {
		return nil, err
	}
	pb, err := kafka.NewConnectorServiceClient(connection).Delete(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	op, err := sdkop.NewOperation(pb, &sdkop.Concretization{
		Poll:         c.pollOperation,
		MetadataType: (*kafka.DeleteConnectorMetadata)(nil),
		ResponseType: (*emptypb.Empty)(nil),
	})
	if err != nil {
		return nil, err
	}
	return &ConnectorDeleteOperation{*op}, nil
}

// ConnectorResumeOperation is used to monitor the state of Resume operations.
type ConnectorResumeOperation struct {
	sdkop.Operation
}

// Metadata retrieves the operation metadata.
func (o *ConnectorResumeOperation) Metadata() *kafka.ResumeConnectorMetadata {
	return o.Operation.Metadata().(*kafka.ResumeConnectorMetadata)
}

// Response retrieves the operation response.
func (o *ConnectorResumeOperation) Response() *kafka.Connector {
	return o.Operation.Response().(*kafka.Connector)
}

// Wait polls the operation until it's done.
func (o *ConnectorResumeOperation) Wait(ctx context.Context, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.Wait(ctx, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// WaitInterval polls the operation until it's done with custom interval.
func (o *ConnectorResumeOperation) WaitInterval(ctx context.Context, pollInterval sdkop.PollIntervalFunc, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.WaitInterval(ctx, pollInterval, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// Resume is an operation of Yandex.Cloud Kafka Connector service.
// It returns an object which should be used to monitor the operation state.
func (c connectorClient) Resume(ctx context.Context, in *kafka.ResumeConnectorRequest, opts ...grpc.CallOption) (*ConnectorResumeOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorResume, opts...)
	if err != nil {
		return nil, err
	}
	pb, err := kafka.NewConnectorServiceClient(connection).Resume(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	op, err := sdkop.NewOperation(pb, &sdkop.Concretization{
		Poll:         c.pollOperation,
		MetadataType: (*kafka.ResumeConnectorMetadata)(nil),
		ResponseType: (*kafka.Connector)(nil),
	})
	if err != nil {
		return nil, err
	}
	return &ConnectorResumeOperation{*op}, nil
}

// ConnectorPauseOperation is used to monitor the state of Pause operations.
type ConnectorPauseOperation struct {
	sdkop.Operation
}

// Metadata retrieves the operation metadata.
func (o *ConnectorPauseOperation) Metadata() *kafka.PauseConnectorMetadata {
	return o.Operation.Metadata().(*kafka.PauseConnectorMetadata)
}

// Response retrieves the operation response.
func (o *ConnectorPauseOperation) Response() *kafka.Connector {
	return o.Operation.Response().(*kafka.Connector)
}

// Wait polls the operation until it's done.
func (o *ConnectorPauseOperation) Wait(ctx context.Context, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.Wait(ctx, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// WaitInterval polls the operation until it's done with custom interval.
func (o *ConnectorPauseOperation) WaitInterval(ctx context.Context, pollInterval sdkop.PollIntervalFunc, opts ...grpc.CallOption) (*kafka.Connector, error) {
	abstract, err := o.Operation.WaitInterval(ctx, pollInterval, opts...)
	response, _ := abstract.(*kafka.Connector)
	return response, err
}

// Pause is an operation of Yandex.Cloud Kafka Connector service.
// It returns an object which should be used to monitor the operation state.
func (c connectorClient) Pause(ctx context.Context, in *kafka.PauseConnectorRequest, opts ...grpc.CallOption) (*ConnectorPauseOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorPause, opts...)
	if err != nil {
		return nil, err
	}
	pb, err := kafka.NewConnectorServiceClient(connection).Pause(ctx, in, opts...)
	if err != nil {
		return nil, err
	}
	op, err := sdkop.NewOperation(pb, &sdkop.Concretization{
		Poll:         c.pollOperation,
		MetadataType: (*kafka.PauseConnectorMetadata)(nil),
		ResponseType: (*kafka.Connector)(nil),
	})
	if err != nil {
		return nil, err
	}
	return &ConnectorPauseOperation{*op}, nil
}

// pollOperation returns the current state of the polled operation.
func (c connectorClient) pollOperation(ctx context.Context, operationId string, opts ...grpc.CallOption) (sdkop.YCOperation, error) {
	connection, err := c.connector.GetConnection(ctx, ConnectorOperationPoller, opts...)
	if err != nil {
		return nil, err
	}
	return operation.NewOperationServiceClient(connection).Get(ctx, &operation.GetOperationRequest{OperationId: operationId}, opts...)
}

var (
	ConnectorGet             = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Get")
	ConnectorList            = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.List")
	ConnectorCreate          = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Create")
	ConnectorUpdate          = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Update")
	ConnectorDelete          = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Delete")
	ConnectorResume          = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Resume")
	ConnectorPause           = protoreflect.FullName("yandex.cloud.mdb.kafka.v1.ConnectorService.Pause")
	ConnectorOperationPoller = protoreflect.FullName("yandex.cloud.operation.OperationService.Get")
)
